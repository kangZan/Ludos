# Ludos v0.1.0 改造后代码点评文档

> 审阅环境：Python 3.12.12 (Anaconda)
> 审阅日期：2026-02-06
> 代码总量：约 40 个 Python 源文件 + 7 个测试文件 + 配置/脚本/文档

---

## 一、总体印象

代码从"纯需求文档 + 提示词模板"出发，经过多轮迭代，已完成一个**可运行**的多智能体叙事推演系统。从日志样例 (`logs/session_a412e4cf.public.log`) 可见系统已实际跑通了"权力的游戏"场景，角色对话质量较好。整体工程化程度**显著超出同类 AI Agent 原型项目**的平均水平。

---

## 二、代码优势

### 2.1 类型系统运用出色

- 全面使用 Python 3.12 的 `str | None` 联合类型语法，无 `Optional` 残留
- `TypedDict` 定义领域类型（`ActionPack`, `CharacterDossier`, `ObjectiveFacts` 等），兼顾类型安全与 dict 的灵活序列化
- `Pydantic BaseModel` 用于 LLM 结构化输出校验（`schemas.py`），与内部 `TypedDict` 分层清晰
- `pyproject.toml` 配置了 `mypy --strict`，ruff target-version = "py312"

```
评价：类型策略成熟，TypedDict 用于内部流转、Pydantic 用于外部校验，分工合理。
```

### 2.2 半结构化解析器（half_structured_parser.py）设计精良

- **核心洞察正确**：不依赖 LLM 输出完美 JSON，转而使用 `[SECTION_NAME]` 分块协议
- 内建中英文双语别名映射（`_SECTION_ALIASES`, `_SECTION_ALIASES_CN`, `_FIELD_ALIASES`）
- 支持内联 header、键值对、列表、字符子块分割等多种模式
- `parse_initialization` / `parse_scene_announcement` / `parse_round_assessment` / `parse_turn_order` 四个入口函数覆盖全流程
- 这是整个系统中**工程含金量最高**的模块

```
评价：这是应对 LLM 输出不确定性的务实方案，别名机制提供了优秀的容错能力。
```

### 2.3 角色记忆文件协议（character_memory.py + memory_protocol.py）

- 使用纯文本文件而非 JSON/数据库存储角色记忆
- `[STATE]` / `[GOALS]` / `[SECRETS]` / `[PRESSURE]` / `[STABLE]` / `[WORKING]` / `[SELF_EVAL]` 七个分块
- 管道分隔符的简单序列化，人类可直接阅读和调试
- `last_public_offset` 追踪已读公共日志偏移量，实现增量读取
- `seed_memory_if_missing` 实现首次初始化，不覆盖已有文件

```
评价：简单、可调试、无外部依赖，非常适合原型阶段。比用数据库更务实。
```

### 2.4 结构化日志

- 使用 `structlog` 替代标准 `logging`
- 开发环境 ConsoleRenderer 带颜色、生产环境 JSONRenderer
- 关键事件均有 `logger.info` 带结构化字段（session_id, round, character 等）
- `setup_logging()` 集中配置

```
评价：日志基础设施到位，满足可观测性要求。
```

### 2.5 工具插件化架构

- `registry.py` 提供 `register_tool` / `get_tool` / `list_tools`
- 通过 `TOOL_PLUGINS` 环境变量动态加载
- `plugins/tools/example.py` 提供示例
- `__init__.py` 的 `register_builtin_tools()` 集中注册内置工具

```
评价：扩展点预留合理，接口简洁。
```

### 2.6 测试质量

- 7 个测试文件覆盖核心确定性逻辑（info_filter, pressure_tracker, end_detector, validators, json_parser, text_formatter）
- `conftest.py` 使用冰与火之歌场景构建 fixture，贴近真实业务
- 测试用例命名清晰（`test_no_leakage_with_legitimate_info`, `test_detects_leakage`, `test_no_self_leakage`）
- 关键边界条件有覆盖（阈值边界、自身动作排除、已揭露秘密跳过）

```
评价：测试策略正确——测确定性逻辑，不测 LLM 调用。fixture 设计用心。
```

### 2.7 其他亮点

| 项 | 说明 |
|---|---|
| `InteractionLogWriter` | 追加写入日志，路径自动建目录 |
| `InteractionStore` | 支持按角色/回合/关键词查询，JSON 持久化 |
| `error.py` | `@dataclass` 基类 + 三级错误层次（Config/Dependency/Runtime） |
| `visualization.py` | Mermaid / PNG 双格式导出，PNG 失败自动降级 Mermaid |
| `scripts/run.py` | 环境检查脚本（Python 版本 / .env / 依赖 / API Key） |
| 流式输出 | `main.py` 通过 `astream(stream_mode="updates")` 实时打印场景/行动/评估 |

---

## 三、代码问题与风险

### 3.1 全局可变单例

```python
# llm_client.py
_llm_instance: ChatOpenAI | None = None

# prompt_loader.py
_cached_prompt: str | None = None
```

**问题**：全局可变状态导致单元测试无法隔离。无法在测试中替换 LLM 客户端或切换提示词。
**严重度**：中。原型阶段可接受，但进入集成测试阶段会成为障碍。

### 3.2 角色子图未实际使用（严重度需重新评估）

`character_subgraph.py` 定义了完整的 build_context → decide_action → validate_action 三节点子图（含重试循环），但 `orchestrator.py` 和 `deduction_loop.py` 中的 `character_turn_node` **直接调用 `decide_action`**，子图未被嵌入。

**但需注意**：由于改造后角色已完全自管私有记忆，信息泄露风险在架构层面已被消除（见下方分析），因此 `validate_no_info_leakage` 的缺失**不构成实际安全风险**。

**实际影响**：
- `character_subgraph.py` 成为死代码，增加维护负担
- 子图中的结构校验（`validate_action_pack`）未执行，可能放过格式不规范的输出
- 但**不存在信息泄露问题**——角色 LLM 的输入中从未包含其他角色的私有数据

**严重度**：低。属于死代码清理问题，非安全风险。

> **关于信息隔离的架构分析**：
> 改造将角色记忆从全局 `DeductionState` 剥离到独立的 `.mem.txt` 文件后，角色 A 的 LLM 提示词中**不存在任何数据通道**能获取角色 B 的私有信息：
> - `filter_visible_actions()` 将 `inner_reasoning` **始终置为空字符串**
> - `format_public_action_line()` **不包含** `inner_reasoning`
> - 角色只读取自己的 `.mem.txt`（稳定记忆、工作记忆、目标、秘密）
> - 主持人 `assess_round_node` 传入空的 `char_goals` 字典
>
> 认知红绿灯的**第一层（结构过滤）和第二层（提示词约束）**已经从根源上阻断了信息泄露。第三层事后验证在新架构下是冗余的安全网，而非必要防线。

### 3.3 压力系统双重实现

| 位置 | 实现方式 |
|---|---|
| `pressure_tracker.py` | 独立工具，遍历全部角色全部秘密，计算增量 |
| `character.py:72-89` | 角色决策时内联计算，只处理当前角色 |

实际运行时，`calculate_pressure_deltas` 虽然被注册为工具，但**从未在图节点中被调用**。压力更新全靠 `character.py` 的内联逻辑。

**后果**：`pressure_tracker.py` 中更完善的逻辑（`CONFLICT_ESCALATION_DELTA` 等）被浪费，两套实现可能产生行为不一致。

**严重度**：中。功能重复，维护负担。

### 3.4 推演循环子图同样未使用

`deduction_loop.py` 的 `build_deduction_loop_graph()` 构建了独立子图，但 `orchestrator.py` 中是**直接导入各节点函数，平铺在顶层图中**。

**后果**：`build_deduction_loop_graph()` 和 `build_initialization_graph()` 都是死代码。模块化设计意图未兑现。

### 3.5 信息过滤器有空操作

```python
# info_filter.py:91-101
def _sanitize_action_content(action: ActionPack) -> str | None:
    content = action.get("action_content")
    if content is None:
        return None
    return content  # 直接原样返回，无任何过滤
```

**问题**：函数名暗示会清理内容，但实际是 pass-through。LLM 可能将内心动机混入 `action_content`，此处本应是过滤防线。

### 3.6 LLM 客户端异常处理逻辑不清

```python
# llm_client.py:84-93
except Exception as exc:
    if response_format is not None and not _supports_structured_output():
        # 此分支在 `response_format is not None` 且 `_supports_structured_output() == False` 时触发
        # 但前面第69行已经判断 `_supports_structured_output()` 为 False 时不走结构化路径
        # 因此这个分支的条件永远为 False（已进入 try 说明走的是非结构化路径）
```

**问题**：异常处理分支存在逻辑死区。当 `_supports_structured_output()` 返回 False 时，代码走第76行的非结构化路径，不会抛异常到 `except` 中触发该条件分支。

**严重度**：低。不影响正确性，但增加阅读困惑。

### 3.7 文件 I/O 混入 Agent 逻辑

```python
# character.py:62-68
if public_log_path:
    with open(public_log_path, "r", encoding="utf-8") as f:
        f.seek(memory.last_public_offset)
        public_delta = f.read()
        memory.last_public_offset = f.tell()
```

**问题**：角色决策函数直接进行文件系统操作，违反单一职责原则。这使得 `decide_action` 无法在没有文件系统的环境中测试。

### 3.8 格式化函数高度重复

`text_formatter.py` 中以下三个函数逻辑几乎相同：

| 函数 | 差异 |
|---|---|
| `format_raw_interaction_log` | 含场景头 + 含 `inner_reasoning` |
| `format_action_line` | 单条 + 含 `inner_reasoning` |
| `format_public_action_line` | 单条 + 不含 `inner_reasoning` |

**问题**：~50 行重复代码，可通过 `include_inner` 参数统一。

### 3.9 缺少 .env.example

README 和 `scripts/run.py` 都引用 `.env.example`，但仓库中**不存在此文件**。新用户无法快速上手。

### 3.10 `pyproject.toml` 版本上限过严

```toml
requires-python = ">=3.12,<3.13"
```

当 Python 3.13 发布后，用户即使环境兼容也无法安装。建议考虑 `>=3.12`。

### 3.11 状态字段 `current_round_actions` 管理复杂

- `announce_scene_node` 将其重置为 `[]`
- `character_turn_node` 通过 `state.get("current_round_actions", []) + [action]` 追加
- 同时 `action_log` 通过 `operator.add` reducer 累积

`current_round_actions` 不使用 reducer，而是每次整体替换，在并发场景下有竞态风险（虽然当前为串行执行）。

---

## 四、Python 3.12 特性利用评估

| 特性 | 使用情况 | 评价 |
|---|---|---|
| `X \| Y` 联合类型 | 全面使用 | 优秀 |
| `match` 语句 | 未使用 | 可在路由函数中替代 if-elif |
| `type` 语句（类型别名） | 未使用 | `ToolFn = Callable[..., object]` 可改为 `type ToolFn = Callable[..., object]` |
| `**kwargs` 类型注解 | 未使用 | 无明显需求 |
| f-string 改进 | 已使用 | 正常 |
| `@override` 装饰器 | 未使用 | 无继承体系，无需使用 |
| `asyncio.TaskGroup` | 未使用 | 角色并行执行可受益 |

```
总评：对 3.12 的利用以类型语法为主，3.12 新增的 asyncio.TaskGroup 和 type 语句可进一步采用。
```

---

## 五、模块质量评分

| 模块 | 质量 | 说明 |
|---|---|---|
| `utils/half_structured_parser.py` | A | 工程含金量最高，别名容错出色 |
| `utils/character_memory.py` | A- | 简洁务实，协议清晰 |
| `tools/pressure_tracker.py` | B+ | 逻辑完善但实际未被调用 |
| `tools/info_filter.py` | B | 核心逻辑正确，`_sanitize_action_content` 空操作 |
| `tools/end_detector.py` | A- | 多条件检测，主角目标优先策略合理 |
| `agents/moderator.py` | B+ | 职责清晰，`_coerce_minimal_initialization` 降级策略好 |
| `agents/character.py` | B- | 功能正确但职责混杂（文件 IO + 压力计算 + LLM 调用） |
| `agents/llm_client.py` | B- | 全局单例 + 异常逻辑死区 |
| `agents/polisher.py` | B+ | 简洁，职责单一 |
| `graphs/orchestrator.py` | B | 功能完整，但子图未嵌套而是平铺 |
| `graphs/state.py` | A- | reducer 设计合理，类型清晰 |
| `graphs/character_subgraph.py` | C | 死代码（但因私有记忆改造，泄露风险已在架构层消除） |
| `graphs/deduction_loop.py` | B- | `build_deduction_loop_graph` 未使用 |
| `graphs/polishing.py` | B- | 同上，未作为子图嵌入 |
| `config/settings.py` | A | Pydantic Settings 规范用法 |
| `config/prompts.py` | A- | 提示词组织清晰，占位符一致 |
| `memory/checkpointer.py` | A- | 优雅降级（Postgres → InMemory） |
| `memory/interaction_store.py` | B+ | 功能完整，查询接口多样 |
| `main.py` | B+ | 流式输出 + 去重 + 自动续传，但函数过长（~170行） |
| `tests/*` | B+ | 覆盖核心逻辑，缺少 agent/graph 层集成测试 |

---

## 六、总结

### 优势清单
1. 类型系统严格且风格统一
2. 半结构化解析器是应对 LLM 不确定性的优秀工程方案
3. 文件制记忆协议简洁可调试
4. 结构化日志到位
5. 插件化工具预留扩展能力
6. 测试覆盖核心确定性逻辑
7. 流式输出 + 自动中断续传
8. 错误降级策略（LLM 解析失败 → 重试 → 最小化初始化）

### 风险清单
1. ~~角色子图未接入 → 信息泄露检测失效~~ **（已修正：私有记忆改造后，信息隔离在架构层已保障，子图验证为冗余安全网，非必要防线）**
2. 压力系统双重实现 → 行为不一致隐患
3. 三个子图均未嵌套使用 → 死代码（非安全风险，属代码整洁问题）
4. 全局可变单例 → 测试隔离困难
5. `_sanitize_action_content` 空操作 → 预留接口未实现
6. `main.py` 函数过长 → 可读性降低
7. 缺少 `.env.example` → 新用户上手障碍

### 架构级安全保障（改造亮点）
改造将角色记忆从全局状态剥离到独立文件后，信息泄露在数据通道层面已不可能发生：
- 角色只读自己的 `.mem.txt`，无法触及其他角色的文件
- `filter_visible_actions()` 强制清空 `inner_reasoning`
- `format_public_action_line()` 不输出 `inner_reasoning`
- 主持人评估传入空的目标字典，不读取角色私有记忆
- 这是本次改造**最关键的架构成就**
